---
title: let&const命令
date: 2020-10-12 16:19:21
tags: ECMAScript
---

# let&const命令

### 01.let命令（不存在变量提升｜暂时性死区｜不允许重复声明）

- let声明的变量只在let命令所在的代码块内有效

- for循环计数器，适用let命令

- for循环设置循环变量那部分为父作用域，循环体内部是单独的子作用域

- var命令会发生“变量提升”变量可以在声明前使用，值为undefined

- let命令必须先声明后使用，否则会报ReferenceError

  - 只要块级作用域内存在let命令，它所声明的变量就binding(绑定)这个区域不再受外部影响

  
  - ES6规定，如果区块中存在let和const命令，这个区块对这些声明变量从一开始就形成封闭作用域，凡是在声明前使用，这些变量就会报错

- let不允许在相同作用域内，重复声明同一个变量

### 02.块级作用域

- ES6允许块级作用域任意嵌套，内层作用域可以定义外层作用域同名变量
  
- 块级作用域使匿名立即执行函数不再必要
  
- 块级作用域中声明函数，函数声明类似于var提升到全局作用域或函数作用域头部，同时还会提升到所在块级作用域头部

  - 块级作用域内部，优先使用函数表达式
  
     ☑️let f=function(){} 
  
     ✖️Function(){}

### 03.const命令

- const声明一个只读常量，一旦声明，值就不能改变（因此需要立即初始化）
- const作用域与let命令相同：只声明所在块级作用域内有效
- const命令声明常量也是不提升，暂时性死区，只能在声明位置后使用
- const声明常量与let一样不可重复使用
- const本质：保证的不是变量值不得改动，而是变量指向的内存地址保存的数据不得改动
  - 对象冻结：object.freeze();

### 04.顶层对象的属性

- 顶层对象在浏览器指Window，在Node中指global

  ES5之中顶层对象和全局变量挂钩，JavaScript设计的缺陷之一，会引发以下问题

  1. 设法在编译时报出变量未声明错误
  2. 不知不觉创建去哪句变量
  3. 顶层对象到处可读写，不利于模块化编程
  4. window实体含义指浏览器窗口对象与顶层冲突

### 05.globalThis对象

- 顶层对象提供全局作用域，所有代码都在这个环境中运行
  - 浏览器中，顶层对象是window，但Node和Web Worker没有Window
  - 浏览器和Web Worker中，Self也指顶层对象，但Node没有Self
  - Node中，顶层对象global，但其他环境都不支持

- 同一段代码为了能够在各种环境取到顶层对象，一般使用this变量但也有局限
  - 全局环境中，this返回顶层对象，但Node.js模块中this返回是当前模块。ES6模块this返回是undefined
  - 函数中this，如果函数单纯作为函数运行而不是作为对象，this会指向顶层对象，但严格模式下this返回undefined。
  - 不管是严格模式还是普通模式，new Function('return this')()会返回全局对象，如果浏览器使用CSP(Content Security Policy)eval和new function都无法使用

*ES2020 globalThis作为顶层对象

