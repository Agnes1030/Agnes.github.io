---
title: 变量的解构赋值
date: 2020-10-13 14:41:37
tags: ECMAScript
---

# 变量的结构赋值

### 01.数组的解构赋值

#### 基本用法

- 直接指定赋值=>数组提取值并对变量赋值

- 写法：“模式匹配”，等号两边的模式相同，左边变量赋予对应的值

  - 解构不成功，变量的值等于undefined 

    ```javascript
    let [foo, [[bar], baz]] = [1, [[2], 3]];
    foo // 1
    bar // 2
    baz // 3
    
    let [ , , third] = ["foo", "bar", "baz"];
    third // "baz"
    
    let [x, , y] = [1, 2, 3];
    x // 1
    y // 3
    
    let [head, ...tail] = [1, 2, 3, 4];
    head // 1
    tail // [2, 3, 4]
    
    let [x, y, ...z] = ['a'];
    x // "a"
    y // undefined
    z // []
    ```

- 不完全解构：等号左边的模式只匹配一部分的等号右边的数组

  ```javascript
  let [x, y] = [1, 2, 3];
  x // 1
  y // 2
  
  let [a, [b], d] = [1, [2, 3], 4];
  a // 1
  b // 2
  d // 4
  ```

- 如果等号右边不是数组（不是课遍历的解构），将会报错

  ```javascript
  // 报错
  let [foo] = 1;
  let [foo] = false;
  let [foo] = NaN;
  let [foo] = undefined;
  let [foo] = null;
  let [foo] = {};
  ```

  - 对于set解构可使用数组的解构赋值

    ```javascript
    let [x, y, z] = new Set(['a', 'b', 'c']);
    x // "a"
    ```

  - 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值

    ```javascript
    function* fibs() {
      let a = 0;
      let b = 1;
      while (true) {
        yield a;
        [a, b] = [b, a + b];
      }
    }
    
    let [first, second, third, fourth, fifth, sixth] = fibs();
    sixth // 5
    ```

#### 默认值

- 解构赋值允许指定默认值

- ES6内部使用“===”判断一个位置是否有值，因此只有当一个数组成员严格等于undefined，默认值才会生效（null不严格等于undefined,默认值不生效）

  ```javascript
  let [x = 1] = [undefined];
  x // 1
  
  let [x = 1] = [null];
  x // null
  ```

- 如果默认值是一个表达式，那么这个表达式时惰性求值的（只有用到时，才会求值）

  ```javascript
  function f() {
    console.log('aaa');
  }
  
  let [x = f()] = [1];
  ```

- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明

  ```javascript
  let [x = 1, y = x] = [];     // x=1; y=1
  let [x = 1, y = x] = [2];    // x=2; y=2
  let [x = 1, y = x] = [1, 2]; // x=1; y=2
  let [x = y, y = 1] = [];     // ReferenceError: y is not defined
  x用y作为默认值时，y还没有声明
  ```

### 02.对象的解构赋值

#### 简介

- 对象解构与数组解构不同：
  - 数组元素是按次序排列的，变量的取值由他的位置决定
  - 对象的属性没有次序，变量必须与属性同名，才能取到正确的值
  - 解构失败，变量的值等于undefined

- 对象的解构赋值，可以很方便地将现有对象的方法赋值到某个变量

  ```javascript
  // 例一
  let { log, sin, cos } = Math;
  
  // 例二
  const { log } = console;
  log('hello') // hello
  
  例一将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。
  例二将console.log赋值到log变量。
  ```

- 如果变量名与属性名不一致时，写法：

  ```javascript
  let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
  baz // "aaa"
  
  let obj = { first: 'hello', last: 'world' };
  let { first: f, last: l } = obj;
  f // 'hello'
  l // 'world'
  ```

- 对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量，真正被赋值的为后者，而不是前者，前者是一个匹配模式，后者才是变量

  ```javascript
  let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
  baz // "aaa"
  foo // error: foo is not defined
  ```

- 与数组一样，解构也可以用于嵌套解构（套娃好复杂，还没学会:smile:）

  ```javascript
  let obj = {
    p: [
      'Hello',
      { y: 'World' }
    ]
  };
  
  let { p: [x, { y }] } = obj;
  x // "Hello"
  y // "World"
  注意，这时p是模式，不是变量，因此不会被赋值。
  ```

**注意，对象的解构赋值可以取到继承的属性。**

#### 默认值

- 对象的解构也可以指定默认值

  ```javascript
  var {x = 3} = {};
  x // 3
  
  var {x, y = 5} = {x: 1};
  x // 1
  y // 5
  
  var {x: y = 3} = {};
  y // 3
  
  var {x: y = 3} = {x: 5};
  y // 5
  
  var { message: msg = 'Something went wrong' } = {};
  msg // "Something went wrong"
  ```

- 默认值生效的条件是，对象的属性值严格等于`undefined`。

  ```javascript
  var {x = 3} = {x: undefined};
  x // 3
  
  var {x = 3} = {x: null};
  x // null
  属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。
  ```

#### 注意点

1. 如果将一个已声明的变量用于解构值，必须非常小心

   ```javascript
   // 错误的写法
   let x;
   {x} = {x: 1};
   // SyntaxError: syntax error
   避免大括号写在行首解释为代码块
   // 正确的写法
   let x;
   ({x} = {x: 1});
   ```

2. 解构赋值允许等号左边的模式之中不放置任何变量名:bowing_woman:

   ```javascript
   //毫无意义但合法，可执行😑
   ({} = [true, false]);
   ({} = 'abc');
   ({} = []);
   ```

3. 由于数组本质是特殊对象，因此可以对数组进行对象属性解构

   ```javascript
   let arr = [1, 2, 3];
   let {0 : first, [arr.length - 1] : last} = arr;
   first // 1
   last // 3
   方括号这种写法，属于“属性名表达式”
   ```

### 03.字符串的解构赋值

- 字符串也可以解构赋值，这是因为此时，字符串被转换成一个类似数组对象

  ```javascript
  const [a, b, c, d, e] = 'hello';
  a // "h"
  b // "e"
  c // "l"
  d // "l"
  e // "o"
  ```

- 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值

  ```javascript
  let {length : len} = 'hello';
  len // 5
  ```

### 04.数值的布尔值和解构赋值

- 解构赋值时，如果等号右边是数值和布尔值，则先转为对象

  ```javascript
  let {toString: s} = 123;
  s === Number.prototype.toString // true
  
  let {toString: s} = true;
  s === Boolean.prototype.toString // true
  ```

- 但undefined与null无法转为对象，对它们进行解构赋值报错TypeError

### 05.函数参数的解构赋值

- 函数参数使用解构赋值

  ```javascript
  function add([x, y]){
    return x + y;
  }
  
  add([1, 2]); // 3
  
  函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。
  ```

- 函数参数解构可以使用默认值

  ```javascript
  function move({x = 0, y = 0} = {}) {
    return [x, y];
  }
  
  move({x: 3, y: 8}); // [3, 8]
  move({x: 3}); // [3, 0]
  move({}); // [0, 0]
  move(); // [0, 0]
  
  函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。
  
  
  function move({x, y} = { x: 0, y: 0 }) {
    return [x, y];
  }
  
  move({x: 3, y: 8}); // [3, 8]
  move({x: 3}); // [3, undefined]
  move({}); // [undefined, undefined]
  move(); // [0, 0]
  
  为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。
  undefined就会触发函数参数的默认值。
  ```

### 06.圆括号问题

- 式子解析为模式还是表达式，必须解析到等号才能判断

- ES6规则：只要有可能导致解构的歧义，就不得使用圆括号。建议不要再模式中放置圆括号🙂

- 不能使用圆括号的解析赋值情况

  1. 变量声明语句

     ```javascript
     // 全部报错
     let [(a)] = [1];
     
     let {x: (c)} = {};
     let ({x: c}) = {};
     let {(x: c)} = {};
     let {(x): c} = {};
     
     let { o: ({ p: p }) } = { o: { p: 2 } };
     ```

  2. 函数声明参数（也属于变量声明）

     ```javascript
     // 报错
     function f([(z)]) { return z; }
     // 报错
     function f([z,(x)]) { return x; }
     ```

  3. 赋值语句的模式

     ```javascript
     // 全部报错
     ({ p: a }) = { p: 42 };
     ([a]) = [5];
     ```

- 可使用圆括号的情况

  赋值语句的非模版部分可以使用圆括号

  ```javascript
  [(b)] = [3]; // 正确
  ({ p: (d) } = {}); // 正确
  [(parseInt.prop)] = [3]; // 正确
  
  首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。
  ```

### 07.变量解构赋值用途

1. 交换变量的值

   ```javascript
   let x = 1;
   let y = 2;
   
   [x, y] = [y, x];
   ```

2. 从函数返回多个值

   ```javascript
   // 返回一个数组
   
   function example() {
     return [1, 2, 3];
   }
   let [a, b, c] = example();
   
   // 返回一个对象
   
   function example() {
     return {
       foo: 1,
       bar: 2
     };
   }
   let { foo, bar } = example();
   ```

3. 函数参数的定义（参数与变量名一一对应）

   ```javascript
   // 参数是一组有次序的值
   function f([x, y, z]) { ... }
   f([1, 2, 3]);
   
   // 参数是一组无次序的值
   function f({x, y, z}) { ... }
   f({z: 3, y: 2, x: 1});
   ```

4. 提取JSON数据

   ```javascript
   let jsonData = {
     id: 42,
     status: "OK",
     data: [867, 5309]
   };
   
   let { id, status, data: number } = jsonData;
   
   console.log(id, status, number);
   // 42, "OK", [867, 5309]
   ```

5. 函数参数值的默认值

   ```javascript
   jQuery.ajax = function (url, {
     async = true,
     beforeSend = function () {},
     cache = true,
     complete = function () {},
     crossDomain = false,
     global = true,
     // ... more config
   } = {}) {
     // ... do stuff
   };
   ```

6. 遍历Map结构

   任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。

   ```javascript
   const map = new Map();
   map.set('first', 'hello');
   map.set('second', 'world');
   
   for (let [key, value] of map) {
     console.log(key + " is " + value);
   }
   // first is hello
   // second is world
   ```

   如果只想获取键名，或者只想获取键值。

   ```javascript
   // 获取键名
   for (let [key] of map) {
     // ...
   }
   
   // 获取键值
   for (let [,value] of map) {
     // ...
   }
   ```

7.输入模块的指定方法

```javascript
const { SourceMapConsumer, SourceNode } = require("source-map");
```





**学习心得**：因为要学Vue，国庆的时候就重新学了上学期的JavaScript，代码这个东西真的一天不碰就要回到解放前的🙂，每天给自己安排的学习计划还是比较紧凑的，同样的，如果不每天复盘一天的知识，不及时去总结，就很快忘记了🙃，JavaScript基础学完以后发现面向对象和ES6在Vue中涉及了很多，所以边学习Vue的同时边来补ES6的语法，跟着阮一峰老师的文档来学，然后结束一章节就自己总结一下✍🏾。希望自己能在学习的时候不要忘的这么快，祈祷n的n次方遍。

